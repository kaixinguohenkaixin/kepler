package txmanager

import (
	"github.com/stretchr/testify/assert"
	pubcom "github.com/vntchain/go-vnt/common"
	"os"
	"path"
	"testing"
)

const (
	ABIPath = "src/github.com/vntchain/kepler/config/public/abi/multi_sign.json"
)

func getGOPATH() string {
	gopath := os.Getenv("GOPATH")
	if gopath == "" {
		panic("Not Set GOPATH")
	}
	return gopath
}

func createContractManager() (cm *ContractManager, err error) {
	gopath := getGOPATH()
	abiPath := path.Join(gopath, ABIPath)
	contractAddress := "0x0410867af739af88e6db5e95d10e1685cd3ddcd5"

	cm, err = newContractManager(abiPath, contractAddress)
	return
}

func TestNewContractManager(t *testing.T) {
	cm, err := createContractManager()
	assert.Equal(t, nil, err, "newContractManager error: %s", err)
	assert.NotEqual(t, nil, cm, "newContractManager return nil")
	t.Logf("ContranctManager: %#v\n", cm)
}

func TestReadUserToCEvent(t *testing.T) {
	cm, _ := createContractManager()

	logUserToC := "LogUserToC"
	data := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x31, 0x61, 0x35, 0x64, 0x30, 0x64, 0x35, 0x65, 0x38, 0x63, 0x35, 0x36, 0x37, 0x34, 0x36, 0x33, 0x62, 0x33, 0x32, 0x63, 0x37, 0x37, 0x33, 0x66, 0x34, 0x63, 0x39, 0x37, 0x31, 0x65, 0x39, 0x66, 0x61, 0x62, 0x62, 0x63, 0x64, 0x65, 0x66, 0x38, 0x62, 0x63, 0x39, 0x35, 0x30, 0x37, 0x62, 0x63, 0x36, 0x34, 0x66, 0x31, 0x39, 0x65, 0x36, 0x37, 0x34, 0x64, 0x65, 0x66, 0x30, 0x37, 0x35, 0x65, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x74, 0x78, 0x69, 0x64, 0x70, 0x32, 0x63, 0x30, 0x30, 0x32, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
	topicsBytes1 := []byte{251, 139, 71, 212, 215, 4, 170, 102, 187, 171, 103, 214, 169, 142, 20, 112, 90, 172, 141, 60, 79, 17, 170, 168, 222, 219, 120, 35, 34, 7, 135, 58}
	topics1 := pubcom.BytesToHash(topicsBytes1)
	topicsBytes2 := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76, 111, 103, 85, 115, 101, 114, 84, 111, 67}
	topics2 := pubcom.BytesToHash(topicsBytes2)
	topicsBytes3 := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 35, 173, 252, 25, 55, 102, 125, 139, 102, 65, 113, 231, 213, 81, 83, 189, 105, 217, 0}
	topics3 := pubcom.BytesToHash(topicsBytes3)
	topicsBytes4 := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 224, 182, 179, 167, 100, 0, 0}
	topics4 := pubcom.BytesToHash(topicsBytes4)
	topics := []pubcom.Hash{topics1, topics2, topics3, topics4}
	blockNumber := uint64(10)
	blockHashBytes := []byte{53, 165, 99, 149, 52, 23, 24, 145, 145, 25, 236, 133, 59, 106, 198, 223, 112, 113, 114, 189, 149, 172, 132, 235, 155, 122, 143, 80, 221, 186, 234, 80}
	blockHash := pubcom.BytesToHash(blockHashBytes)
	txHashBytes := []byte{214, 124, 197, 216, 243, 158, 190, 9, 141, 55, 48, 151, 143, 9, 43, 62, 241, 220, 39, 190, 198, 228, 70, 91, 247, 205, 169, 15, 215, 8, 97, 51}
	txHash := pubcom.BytesToHash(txHashBytes)
	txIndex := uint(1)
	removed := false

	userToC, err := cm.ReadUserToCEvent(logUserToC, data, topics, blockNumber, blockHash, txHash, txIndex, removed)
	assert.Equal(t, nil, err, "ReadUserToCEvent error: %s", err)
	assert.NotEqual(t, nil, userToC, "ReadUserToCEvent return nil")
	t.Logf("UserToC Event: %#v\n", *userToC)

}
